{"version":3,"file":"collision-detect.js","sourceRoot":"","sources":["../../src/util/collision-detect.ts"],"names":[],"mappings":"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","sourcesContent":["import { isNumber } from '@antv/util';\nimport { Point } from '../dependents';\n\ntype Vec2 = [number, number];\n\ntype Item = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  visible?: boolean;\n};\n/**\n * 定义投影对象\n */\ntype Projection = { min: number; max: number };\n\nfunction dot(a, b) {\n  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n}\n\n/**\n * @private\n * 1. 获取投影轴\n */\nfunction getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  }\n  // 获取向量\n  const vector = (start: Point, end: Point): Vec2 => {\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n  const AB = vector(points[0], points[1]);\n  const BC = vector(points[1], points[2]);\n\n  return [AB, BC];\n}\n\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\nfunction rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n  const { x, y } = point;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n  };\n}\n\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\nfunction getRectPoints(box: Item): Point[] {\n  const points = [\n    { x: box.x, y: box.y },\n    { x: box.x + box.width, y: box.y },\n    { x: box.x + box.width, y: box.y + box.height },\n    { x: box.x, y: box.y + box.height },\n  ];\n\n  const rotation = box.rotation;\n  if (rotation) {\n    return [\n      rotateAtPoint(points[0], rotation, points[0]),\n      rotateAtPoint(points[1], rotation, points[0]),\n      rotateAtPoint(points[2], rotation, points[0]),\n      rotateAtPoint(points[3], rotation, points[0]),\n    ];\n  }\n\n  return points;\n}\n\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\nfunction getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return { min: 0, max: 0 };\n  }\n\n  const scalars = [];\n  points.forEach((point) => {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n\n  return { min: Math.min(...scalars), max: Math.max(...scalars) };\n}\n\nfunction isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\n\nfunction isValidNumber(d: number) {\n  return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n}\n\nfunction isValidBox(box: Item) {\n  return ['x', 'y', 'width', 'height'].every(attr => isValidNumber(box[attr]))\n}\n\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\nexport function isIntersectRect(box1: Item, box2: Item, margin: number = 0): boolean {\n  return !(\n    box2.x > box1.x + box1.width + margin ||\n    box2.x + box2.width < box1.x - margin ||\n    box2.y > box1.y + box1.height + margin ||\n    box2.y + box2.height < box1.y - margin\n  );\n}\n\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\nexport function intersect(box1: Item, box2: Item, margin: number = 0) {\n  // 如果两个 box 中有一个是不合法的 box，也就是不会被渲染出来的，那么它们就不相交。\n  if (!isValidBox(box1) || !isValidBox(box2)) return false;\n\n  // 如果两个矩形没有旋转，使用快速判断\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2, margin);\n  }\n\n  // 分别获取 4 个关键点\n  const rect1Points = getRectPoints(box1);\n  const rect2Points = getRectPoints(box2);\n\n  // 获取所有投影轴\n  const axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const projection1 = getProjection(rect1Points, axis);\n    const projection2 = getProjection(rect2Points, axis);\n\n    // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n    if (!isProjectionOverlap(projection1, projection2)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"]}