{"version":3,"file":"hide-overlap.js","sourceRoot":"","sources":["../../../../../src/geometry/label/layout/worker/hide-overlap.ts"],"names":[],"mappings":"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","sourcesContent":["const onmessage = function (e) {\n  type Item = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rotation?: number;\n    visible?: boolean;\n  };\n\n  // Copy from src/util/collision-detect.ts\n  function generateUtils() {\n    type Vec2 = [number, number];\n\n    type Point = { x: number; y: number };\n\n    /**\n     * 定义投影对象\n     */\n    type Projection = { min: number; max: number };\n\n    function dot(a, b) {\n      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n    }\n    /**\n     * 1. 获取投影轴\n     */\n    function getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n      // 目前先处理 平行矩形 的场景, 其他多边形不处理\n      if (points.length > 4) {\n        return [];\n      }\n      // 获取向量\n      const vector = (start: Point, end: Point): Vec2 => {\n        return [end.x - start.x, end.y - start.y];\n      };\n\n      // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n      const AB = vector(points[0], points[1]);\n      const BC = vector(points[1], points[2]);\n\n      return [AB, BC];\n    }\n\n    /**\n     * 绕指定点顺时针旋转后的点坐标\n     * 默认绕原点旋转\n     */\n    function rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n      const { x, y } = point;\n      return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n      };\n    }\n\n    /**\n     * @private\n     * 转化为顶点坐标数组\n     *\n     * @param {Object} box\n     */\n    function getRectPoints(box: Item): Point[] {\n      const points = [\n        { x: box.x, y: box.y },\n        { x: box.x + box.width, y: box.y },\n        { x: box.x + box.width, y: box.y + box.height },\n        { x: box.x, y: box.y + box.height },\n      ];\n\n      const rotation = box.rotation;\n      if (rotation) {\n        return [\n          rotateAtPoint(points[0], rotation, points[0]),\n          rotateAtPoint(points[1], rotation, points[0]),\n          rotateAtPoint(points[2], rotation, points[0]),\n          rotateAtPoint(points[3], rotation, points[0]),\n        ];\n      }\n\n      return points;\n    }\n\n    /**\n     * 2. 获取多边形在投影轴上的投影\n     *\n     * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n     * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n     */\n    function getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n      // 目前先处理矩形的场景\n      if (points.length > 4) {\n        return { min: 0, max: 0 };\n      }\n\n      const scalars = [];\n      points.forEach((point) => {\n        scalars.push(dot([point.x, point.y], axis));\n      });\n\n      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };\n    }\n\n    function isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n      return projection1.max > projection2.min && projection1.min < projection2.max;\n    }\n\n    function isValidNumber(d: number) {\n      return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n    }\n\n    function isValidBox(box: Item) {\n      return ['x', 'y', 'width', 'height'].every(attr => isValidNumber(box[attr]))\n    }\n\n    function isIntersectRect(box1: Item, box2: Item, margin: number = 0): boolean {\n      return !(\n        box2.x > box1.x + box1.width + margin ||\n        box2.x + box2.width < box1.x - margin ||\n        box2.y > box1.y + box1.height + margin ||\n        box2.y + box2.height < box1.y - margin\n      );\n    }\n    function intersect(box1: Item, box2: Item, margin: number = 0) {\n      if (!isValidBox(box1) || !isValidBox(box2)) return false;\n\n      // Quick detect, if rotation is null or zero.\n      if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n      }\n\n      // 分别获取 4 个关键点\n      const rect1Points = getRectPoints(box1);\n      const rect2Points = getRectPoints(box2);\n\n      // 获取所有投影轴\n      const axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n      for (let i = 0; i < axes.length; i++) {\n        const axis = axes[i];\n        const projection1 = getProjection(rect1Points, axis);\n        const projection2 = getProjection(rect2Points, axis);\n\n        if (!isProjectionOverlap(projection1, projection2)) return false;\n      }\n\n      return true;\n    }\n    return { intersect }\n  }\n  const { intersect } = generateUtils();\n\n  // Label layouts.\n  function hideOverlap(items: Item[]) {\n    const boxes = items.slice();\n    for (let i = 0; i < boxes.length; i++) {\n      const box1 = boxes[i];\n      if (box1.visible) {\n        for (let j = i + 1; j < boxes.length; j++) {\n          const box2 = boxes[j];\n          if (box1 !== box2 && box2.visible) {\n            if (intersect(box1, box2)) {\n              box2.visible = false;\n            }\n          }\n        }\n      }\n    }\n    return boxes;\n  }\n\n  const methods = {\n    'hide-overlap': hideOverlap,\n  }\n\n  // Main\n  try {\n    const eventData = JSON.parse(e.data);\n    if (!eventData || !eventData.type || !methods[eventData.type]) return;\n\n    const { type, items } = eventData;\n    const result = methods[type](items);\n    self.postMessage(result);\n  } catch (e) {\n    throw e;\n  }\n}\n\nconst code = `\n   self.onmessage = ${onmessage.toString()}\n`\nexport { code };\n"]}